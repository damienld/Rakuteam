# -*- coding: utf-8 -*-
"""11_Analyse_predictions.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1NxL1MeiSuDQjd2evwxilYrSCJtYCEOVC

<a href="https://colab.research.google.com/github/JulienJ-44/rakuteam/blob/main/11_bis_Vote_3_mod%C3%A8les_ypred_proba_text_0_82_img_0_55.ipynb" target="_parent"><img src="https://colab.research.google.com/assets/colab-badge.svg" alt="Open In Colab"/></a>
"""


# Commented out IPython magic to ensure Python compatibility.
import pandas as pd
import numpy as np
import requests
import io
import streamlit as st
import constants
  
#y_pred_proba= pd.read_csv("../y_pred_proba/ypred_proba_RandomForest_Global_score0_74.csv")#(io.StringIO(download.decode('utf-8')))
#y_pred_proba.head()
model_index = 1#input("Select a model: 1-RF, 2-CNN image, 3-DNN texte, default-weighted voting")
print(model_index)

def load_df_code_designation(index=0):
  url = constants.path + "Demo/df_classes_avec_code_libelle_code026.csv"
  df = pd.read_csv(url, index_col=index)
  return df

df_code_designation = load_df_code_designation()

def display_keywords_fromclasscodes(code_classe_reelle):#, code_classe_predite):
  dataf_code_designation=load_df_code_designation()
  print(dataf_code_designation.head())
  ligne=dataf_code_designation[dataf_code_designation["prdtypecode"]==code_classe_reelle]
  classe_reelle_name=str(ligne.iloc[0,1])
  print("classe réelle:", classe_reelle_name)
  #ligne=dataf_code_designation[dataf_code_designation["prdtypecode"]==code_classe_predite]
  #classe_predite_name=str(ligne.iloc[0,1])
  #print("classe prédite:", classe_predite_name)
  return display_keywords_fromclassnames(classe_reelle_name)#,classe_predite_name)

def display_keywords_fromclassnames(name_classe_reelle):#, name_classe_predite):
  print(name_classe_reelle)
  dataf_code_designation=load_df_code_designation()
  ligne=dataf_code_designation[dataf_code_designation["désignation"]==name_classe_reelle]
  classe_reelle_code026=str(ligne.iloc[0,2])
  print(classe_reelle_code026)
  #classe_predite_code026=(dataf_code_designation[dataf_code_designation["désignation"]==name_classe_predite]).code_0a26
  classe_reelle_code=str(ligne.iloc[0,0])
  print(classe_reelle_code)
  #classe_predite_code=(dataf_code_designation[dataf_code_designation["désignation"]==name_classe_predite]).prdtypecode

  import pickle
  import constants
  # reading the dictionnary des 15 keyword
  with open(constants.path+'dico_keywords_tfidf_15.pkl', 'rb') as handle: 
    data = handle.read() 
  # reconstructing the data as dictionary 
  lst_keywords_byclass = pickle.loads(data) 
  #print("Classe:",classe_reelle_code, " ", classe_reelle_code026)
  #print(lst_keywords_byclass[int(classe_reelle_code)])
  #print("Classe:",classe_predite_code, " ", classe_predite_code026)
  #print(lst_keywords_byclass[int(classe_predite_code)])
  #df_comparekeywords[classe_reelle_code]=lst_keywords_byclass[int(classe_reelle_code)]
  df_comparekeywords=pd.DataFrame(index=np.arange(15)+1)
  print(df_comparekeywords.head())
  lst=[key for key in lst_keywords_byclass[int(classe_reelle_code)]]
  lst2=list(lst_keywords_byclass[int(classe_reelle_code)].values())
  print(lst2)
  df_comparekeywords[name_classe_reelle]=lst
  df_comparekeywords["tfidf"]=lst2
  print(df_comparekeywords.head())
  #df_comparekeywords[classe_predite_code]=[key for key in lst_keywords_byclass[int(classe_predite_code)]]
  #df_comparekeywords[classe_reelle_code+"_"]=[lst_keywords_byclass[key] for key in lst_keywords_byclass[int(classe_reelle_code)]]
  #df_comparekeywords[classe_predite_code+"_"]=[lst_keywords_byclass[key] for key in lst_keywords_byclass[int(classe_predite_code)]]
  return (df_comparekeywords)

def get_ytest():
  url = constants.pathRoot+ "y_pred_proba/y_test.csv"# Make sure the url is the raw version of the file on GitHub
  y_test = pd.read_csv(url)
  # Remplacer les labels de 0 à 26
  y_test = y_test.replace({'prdtypecode': {10: 1, 2280:2,   50:3, 1280:4, 2705:5, 2522:6, 2582:7, 1560:8, 1281:9, 1920:10, 2403:11,
        1140:12, 2583:13, 1180:14, 1300:15, 2462:16, 1160:17, 2060:18,   40:19,   60:20, 1320:21, 1302:22,
        2220:23, 2905:24, 2585:25, 1940:26, 1301:0}})
  try:
    y_test = y_test.drop('Unnamed: 0', axis =1)
  except:
    print("(2)no columns Unnamed: 0")
  return y_test
@st.cache
def get_ytrain():
  #url = "https://raw.githubusercontent.com/JulienJ-44/rakuteam/main/y_pred_proba/y_train.csv"# Make sure the url is the raw version of the file on GitHub
  #download = requests.get(url).content
  #y_train = pd.read_csv(io.StringIO(download.decode('utf-8')))
  y_train= pd.read_csv(constants.pathRoot+"y_pred_proba/y_train.csv")
  # Remplacer les labels de 0 à 26
  return y_train
@st.cache
def set_model_name(model_index):
  if (model_index == "1"):
    model_selected="Random Forest"    
  elif (model_index == "2"):
    model_selected="CNN images"  
  elif (model_index == "3"):
    model_selected="DNN texte"  
  else:
    model_selected="weighted voting"
  return model_selected
@st.cache
def calc_y_pred(model_index):
  if (model_index == "1"):
    #url = "https://raw.githubusercontent.com/JulienJ-44/rakuteam/main/y_pred_proba/ypred_proba_RandomForest_Global_score0_74.csv"
    #download = requests.get(url).content
    y_pred_proba= pd.read_csv(constants.pathRoot+ "y_pred_proba/ypred_proba_RandomForest_Global_score0_74.csv")#(io.StringIO(download.decode('utf-8')))
  elif (model_index == "2"):
    y_pred_proba= pd.read_csv(constants.pathRoot+ "y_pred_proba/ypred_proba_model_image_final_train_test.csv")
  elif (model_index == "3"):
    y_pred_proba= pd.read_csv(constants.pathRoot+ "y_pred_proba/ypred_proba_DnnText_score0_82.csv")
  else:
    y_pred_proba_rf = pd.read_csv(constants.pathRoot+ "y_pred_proba/ypred_proba_RandomForest_Global_score0_74.csv")
    y_pred_proba_dnntext = pd.read_csv(constants.pathRoot+ "y_pred_proba/ypred_proba_DnnText_score0_82.csv")
    y_pred_proba_img = pd.read_csv(constants.pathRoot+ "y_pred_proba/ypred_proba_model_image_final_train_test.csv")
    score1_rf = 0.74
    score2_dnntext = 0.82
    score3_img = 0.58
    y_pred_proba = (score1_rf * y_pred_proba_rf + score2_dnntext * y_pred_proba_dnntext + score3_img * y_pred_proba_img) / (score1_rf + score2_dnntext + score3_img)
  # Drop les colonnes inutiles
  try:
      y_pred_proba = y_pred_proba.drop('Unnamed: 0', axis =1)
  except:
    print("(1)no columns Unnamed: 0")
  return y_pred_proba

from sklearn.metrics import accuracy_score
from sklearn import metrics

@st.cache
def get_classifreport(index_model):
  model_index=index_model
  y_test=get_ytest()
  y_train=get_ytrain()
  model_selected=set_model_name(index_model)
  y_pred_proba=calc_y_pred(index_model)
  #preparation des données pour le crosstab
  # Convertir Dataframe en array
  y_pred_proba_arr = y_pred_proba.to_numpy()
  y_test = y_test.to_numpy()
  # on prend l'index de la proba la + élevée
  # pour récupérer les classes
  y_pred = y_pred_proba_arr.argmax(axis=1)
  # Pour ajouter une dimension en plus
  y_pred = np.reshape(y_pred, (-1, 1))
  return(metrics.classification_report(y_test, y_pred))

@st.cache
def get_crosstab(index_model):
  print("0")    
  model_index=index_model
  y_test=get_ytest()
  y_train=get_ytrain()
  model_selected=set_model_name(index_model)
  y_pred_proba=calc_y_pred(index_model)
  #preparation des données pour le crosstab
  # Convertir Dataframe en array
  y_pred_proba_arr = y_pred_proba.to_numpy()
  y_test = y_test.to_numpy()
  # on prend l'index de la proba la + élevée
  # pour récupérer les classes
  y_pred = y_pred_proba_arr.argmax(axis=1)
  # Pour ajouter une dimension en plus
  y_pred = np.reshape(y_pred, (-1, 1))
  # Crosstab avec ravel pr enlever dimension et eviter message d'erreur (Error: If using all scalar values, you must pass an index)
  print("1")    
  dfcross = pd.crosstab(y_test.ravel(), y_pred.ravel(), rownames=['Classe réelle'], colnames=['Classe prédite'],normalize = 0) #TODO remettre ,normalize = 0  
  dfcross = dfcross.sort_index(axis=0)
  dfcross = dfcross.sort_index(axis=1)
  print("2")    
  df_code_designation = load_df_code_designation()
  listnames = [(str(df_code_designation.iloc[index,0]) + "-" +  str(df_code_designation.iloc[index,1])) for index in range(len(df_code_designation))]
  dfcross.columns = listnames
  dfcross.index = listnames
  return dfcross

#get_crosstab("1")